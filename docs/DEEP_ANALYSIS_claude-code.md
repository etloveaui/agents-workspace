# 심층 분석 보고서: claude-code

**문서 ID:** DA-20250903-CC
**상태:** 완료
**작성자:** Gemini (System Architect 페르소나)

## Executive Summary

본 문서는 `claude-code` GitHub 저장소의 전체 구조와 문서를 심층 분석하여, 해당 프로젝트의 핵심 설계 사상과 아키텍처, 그리고 우리 `agents-workspace` 프로젝트에 적용할 수 있는 전략적 시사점을 도출한 결과물이다.

`claude-code`의 핵심은 **'개발자의 터미널 워크플로우에 자연스럽게 통합되는 AI 파트너'**라는 철학 아래, **'실행 가능한 레시피(Runnable Recipe)'로서의 마크다운 파일**을 동적 컨텍스트로 활용하는 정교한 아키텍처를 구현한 점이다. 특히, 각 작업의 보안 경계를 설정하는 `allowed-tools` 개념과, `@-mention` 및 `grep` 등을 활용한 다층적 코드베이스 인식 메커니즘은 우리 프로젝트가 벤치마킹해야 할 매우 중요한 혁신이다.

본 보고서는 이 시스템을 분석하고, 여기서 얻은 통찰을 바탕으로 우리 워크스페이스에 **'슬래시 커맨드 패턴'**과 **'에이전트 헌법'** 개념을 도입하고, 기존에 제안했던 **'공유 저널' 아이디어를 한층 더 강화**하는 구체적인 실행 방안을 제안한다.

---

## 1. 핵심 철학: 보이지 않는 AI 파트너

`claude-code`는 개발자가 새로운 GUI나 웹사이트로 컨텍스트를 전환하게 만드는 대신, 이미 익숙한 터미널 환경 자체를 지능적으로 만드는 것을 목표로 한다. `CHANGELOG.md`에 기록된 수많은 기능(Vim 키 바인딩, 셸 명령어 실행, 백그라운드 작업 등)들은 모두 개발자가 기존의 작업 흐름을 유지하면서 AI의 도움을 받을 수 있도록 하는 데 초점이 맞춰져 있다. 이는 AI를 '별도의 도구'가 아닌, '터미널의 확장 기능'처럼 느끼게 하려는 명확한 설계 의도를 보여준다.

---

## 2. 시스템 아키텍처: Core Engine + Context Files

`claude-code`의 아키텍처는 단순하지만 매우 효과적인 **'Core Engine + Context Files'** 구조로 이루어져 있다.

-   **Core Engine:** `claude` 실행 바이너리. 사용자 인터페이스, 모델과의 통신, 대화 내용 관리 등 핵심 기능을 담당한다.
-   **Context Files:** 에이전트의 행동을 결정하는 두뇌 역할을 하며, 정적 컨텍스트와 동적 컨텍스트로 나뉜다.
    -   **정적 컨텍스트 (Static Context):** `CLAUDE.md` 파일이 이 역할을 수행하는 것으로 추정된다. (v0.2.107 로그 참조). 이 파일은 에이전트의 기본 정체성, 작동 원칙, 전반적인 규칙 등 쉽게 변하지 않는 '헌법'과 같은 정보를 담는다.
    -   **동적 컨텍스트 (Dynamic Context):** 이 아키텍처의 핵심 혁신. `.claude/commands/` 디렉토리 내의 `.md` 파일들이 '슬래시 커맨드'의 형태로 동적 컨텍스트를 제공한다. 이 파일들은 단순한 텍스트가 아니라, 다음과 같은 구조를 가진 **'실행 가능한 레시피'**이다.
        -   **YAML Frontmatter (머리말):** 파일 상단 `---`로 둘러싸인 부분. 해당 작업을 수행하는 데 필요한 **보안 경계(`allowed-tools`)**와 커맨드에 대한 사용자용 **설명(`description`)**을 정의한다.
        -   **Markdown Body (본문):** 커맨드가 실행될 때 AI에게 주입되는 상세한 프롬프트. AI가 따라야 할 **단계별 지침**과, `!git status`처럼 실시간 정보를 수집하기 위한 **셸 명령어**를 포함한다.

이 구조를 통해, `claude-code`는 일반적인 대화를 할 때와, 특정 전문 작업(`/commit-push-pr`)을 수행할 때 AI의 행동 모드와 권한을 동적으로 전환하는 정교한 제어 시스템을 구현했다.

---

## 3. '코드베이스 인식' 메커니즘

에이전트가 코드베이스를 '이해'하는 능력은 다음 4가지 기능의 유기적인 조합을 통해 달성된다.

1.  **기본 파일 접근 (`Read` 도구):** 가장 기본적인 기능으로, 명시된 경로의 파일을 직접 읽는다.
2.  **사용자 주도 컨텍스트 주입 (`@-mention`):** 사용자가 대화 중에 `@` 기호로 파일명을 언급하면, 해당 파일의 내용이 즉시 대화의 컨텍스트에 포함된다. 이는 사용자가 필요로 하는 정보를 능동적으로, 그리고 정확하게 AI에게 제공하는 효과적인 방법이다.
3.  **능동적 정보 탐색 (`Grep` 도구):** 에이전트는 특정 함수나 변수의 정의, 사용 위치 등을 코드베이스 전체에서 스스로 검색할 수 있다. 이는 단일 파일 분석을 넘어, 프로젝트 전체의 상호의존성을 파악하는 데 결정적인 역할을 한다.
4.  **실시간 상태 파악 (동적 명령어):** 슬래시 커맨드 레시피에 포함된 `!git diff HEAD`와 같은 명령어는, 작업이 실행되는 바로 그 순간의 워크스페이스 상태(예: 스테이징된 변경사항)를 동적으로 조회하여 컨텍스트에 주입한다. 이를 통해 항상 최신 정보를 바탕으로 결정을 내릴 수 있다.

---

## 4. 핵심 워크플로우 예시: 버그 수정부터 PR 생성까지

이러한 아키텍처가 실제 워크플로우에서 어떻게 동작하는지는 다음과 같이 재구성할 수 있다.

1.  **시작:** 사용자가 `claude`를 실행하고, GitHub 이슈의 버그 리포트를 대화창에 붙여넣는다.
2.  **탐색:** 에이전트는 버그 리포트에 언급된 함수명을 `grep` 도구를 사용해 코드베이스 전체에서 검색하여 위치를 찾아낸다.
3.  **분석:** 사용자는 검색된 파일 경로를 `@-mention`하여 전체 파일 내용을 컨텍스트에 로드하고, 에이전트는 이를 바탕으로 근본 원인을 분석하여 수정안을 코드 형태로 제안한다.
4.  **수정:** 사용자의 동의 하에, 에이전트는 `Edit` 도구를 사용하여 실제 파일에 수정사항을 적용한다.
5.  **마무리 (자동화):** 사용자가 `/commit-push-pr` 커맨드를 실행한다. 에이전트는 `commit-push-pr.md` 레시피에 따라, `allowed-tools`에 명시된 `git` 관련 명령어들만을 사용하여 브랜치를 생성하고, 커밋 메시지를 작성하며, 원격 저장소에 푸시한 뒤, `gh` 명령어로 Pull Request까지 생성하는 전 과정을 자동으로 수행한다.

---

## 5. `agents-workspace`를 위한 전략적 시사점 및 제안

`claude-code` 분석을 통해 얻은 통찰은 우리 워크스페이스를 한 단계 발전시킬 구체적인 아이디어로 이어진다.

### 제안 1: '슬래시 커맨드' 패턴 도입
-   **현황:** 현재 우리의 복잡한 작업(리팩토링, 문서화 등)은 표준화된 절차 없이, 그때그때의 프롬프트에 의존한다.
-   **제안:** `.codex/commands/` 와 같은 디렉토리를 생성하고, `claude-code`처럼 `.md` 파일로 된 '워크플로우 레시피'를 만들자. 예를 들어, `refactor.md` 파일에는 리팩토링에 필요한 `allowed-tools`와 단계별 프롬프트를 정의할 수 있다. 이는 우리의 핵심 작업을 **버전 관리가 가능하고, 재사용 가능하며, 안전한 방식**으로 표준화하는 길이다.

### 제안 2: '에이전트 헌법' 정립
-   **현황:** `.gemini/`, `.codex/` 등에 `RULES.md`, `PRINCIPLES.md` 등 여러 규칙 파일이 흩어져 있다.
-   **제안:** `claude-code`의 `@-import` 개념을 벤치마킹하여, 이들을 모두 포함하는 단일 마스터 파일(예: `MASTER_GEMINI.md`)을 만들자. 이는 에이전트의 핵심 정체성과 운영체계를 한 곳에서 명확하게 관리할 수 있게 해준다.

### 제안 3: '공유 저널' 아이디어 강화
-   **현황:** 이전에 '공유 워크스페이스 저널' 아키텍처를 설계했다.
-   **제안:** 저널의 이벤트 스키마에 `trigger` 필드를 추가하자. 만약 작업이 슬래시 커맨드에 의해 시작되었다면, `{"type": "slash_command", "name": "/commit-push-pr"}` 와 같이 기록한다. 이를 통해 우리는 단순히 '무슨 일이 일어났는가'를 넘어, **'어떤 표준화된 절차에 의해 그 일이 일어났는가'**까지 추적할 수 있게 되어, 저널의 분석 가치를 극대화할 수 있다.
